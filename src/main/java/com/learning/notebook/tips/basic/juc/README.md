线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另外一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。
线程互斥是指对于共享的进程系统资源，每个线程访问时的排他性。当有若干个线程都要使用某一个共享资源时，任何时刻最多只允许一个线程去使用，其他线程必须等待，知道占用占用资源者释放该资源。
线程互斥可以看成是一种特殊的线程同步。

Thread.join(),使用线程的join方法的阻塞效果来达到顺序执行的效果；调用join（）方法可以看到源码中阻塞主线程执行直到子线程执行完之后才会结束等待；
1. 利用Executors线程池，原理是方法内部是一个基于FIFO的队列，也就是线程池会根据我们的添加顺序来执行多添加的任务
2. 使用Lock/Condition的方法来达到顺序的效果；Condition一般都是与一个锁进行关联，作为多线程间协调通信的工具类，使得某些线程一起等待某个特定的条件（await()），而只有当这个条件具备时（signal()/signalAll()）这些线程才会被唤醒从而重新争夺锁；
3. 使用线程的CountDownLatch（倒计数）方法,利用它可以实现类似计数器的功能，当count为0时被阻塞的线程才会继续执行；
4. 使用CyclicBarrier(回环栅栏)实现线程按顺序运行；CyclicBarrier(回环栅栏):通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。
5. 使用Semaphore(信号量)实现线程按顺序运行；Semaphore(信号量):Semaphore是一个计数信号量,从概念上将，Semaphore包含一组许可证,如果有需要的话，每个acquire()方法都会阻塞，直到获取一个可用的许可证,每个release()方法都会释放持有许可证的线程，并且归还Semaphore一个可用的许可证。
然而，实际上并没有真实的许可证对象供线程使用，Semaphore只是对可用的数量进行管理维护。acquire():当前线程尝试去阻塞的获取1个许可证,此过程是阻塞的,当前线程获取了1个可用的许可证，则会停止等待，继续执行。release():当前线程释放1个可用的许可证。



CountDownLatch 是计数器，线程完成一个就记一个，就像 报数一样，只不过是递减的。
CyclicBarrier更像一个水闸，线程执行就想水流，在水闸处都会堵住，等到水满(线程到齐)了，才开始泄流。
与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。

Semaphore包含一组许可证,如果有需要的话，
每个acquire()方法都会阻塞，直到获取一个可用的许可证,
每个release()方法都会释放持有许可证的线程，并且归还Semaphore一个可用的许可证。然而，实际上并没有真实的许可证对象供线程使用，Semaphore只是对可用的数量进行管理维护。

acquire():当前线程尝试去阻塞的获取1个许可证,此过程是阻塞的,当前线程获取了1个可用的许可证，则会停止等待，继续执行。

release():当前线程释放1个可用的许可证。


ReentrantLock:
1. 基于在语言层面实现的锁，需要lock()和unlock()方法配合try/finally语句块来完成。
2. 等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。
3. 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。
4. 提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。
> - ReentrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。
> - 在ReentrantLock 中，lock()方法是一个无条件的锁，与synchronize意思差不多
> - 另一个方法 tryLock()方法只有在成功获取了锁的情况下才会返回true，如果别的线程当前正持有锁，则会立即返回false！为这个方法加上timeout参数，则会在等待timeout的时间才会返回false或者在获取到锁的时候返回true。
Synchronized:
1. 是基于在语言层面实现的锁，由编译器去保证锁的加锁和释放。
> - 对于同步方法，锁是当前实例对象。
> - 对于静态同步方法，锁是当前对象的Class对象。
> - 对于同步方法块，锁是Synchronized括号里配置的对象。

~~~Java
/**
 * lock.lock();
 * 当锁可用，并且当前线程没有持有该锁，直接获取锁并把count set为1.
 * 当锁可用，并且当前线程已经持有该锁，直接获取锁并把count增加1.即重入。
 * 当锁不可用，那么当前线程被阻塞，休眠一直到该锁可以获取，然后把持有count设置为1.
 * => 小结：该种方式获取锁不可中断，如果获取不到则一直休眠等待。
 */
/**
 * lock.tryLock();
 * 当获取锁时，只有当该锁资源没有被其他线程持有才可以获取到，并且返回true，同时设置持有count为1；
 * 当获取锁时，当前线程已持有该锁，那么锁可用时，返回true，同时设置持有count加1；即重入。
 * 当获取锁时，如果其他线程持有该锁，无可用锁资源，直接返回false，这时候线程不用阻塞等待，可以先去做其他事情；
 * 即使该锁是公平锁fairLock，使用tryLock()的方式获取锁也会是“非公平”的方式，只要获取锁时该锁可用那么就会直接获取并返回true。
 * 这种直接插入的特性在一些特定场景是很有用的。但是如果就是想使用“公平”的方式的话，可以试一试tryLock(0, TimeUnit.SECONDS)，几乎跟公平锁没区别，只是会监测中断事件。
 */
/**
 * lock.tryLock(long timeout, TimeUnit unit)
 * 从上面代码中可以看出，获取锁成功或者超时之后返回。而且在公平锁和非公平锁的场景下都可以使用，只是会增加对中断事件的监测。
 * 当获取锁时，锁资源在超时时间之内变为可用，并且在等待时没有被中断，那么当前线程成功获取锁，返回true，同时当前线程持有锁的count设置为1.
 * 当获取锁时，在超时时间之内没有锁资源可用，那么当前线程获取失败，不再继续等待，返回false.
 * 当获取锁时，在超时等待时间之内，被中断了，那么抛出InterruptedException，不再继续等待.
 * 当获取锁时，在超时时间之内锁可用，并且当前线程之前已持有该锁，那么成功获取锁，同时持有count加1.
 */
/**
 * lock.lockInterruptibly();
 * 当获取锁时，锁资源可用，那么当前线程成功获得锁，同时持有count设置为1，返回true.
 * 当获取锁时，锁资源可用，当前线程已持有该锁，它成功获取该锁，同时持有count增加1，返回true.
 * 当获取锁时，锁资源不可用，线程开始阻塞休眠等待，如果等待过程中如果有中断事件，那么会停止等待，立即返回.
 * 当获取锁时，锁资源不可用，线程开始阻塞休眠等待，如果等待过程中锁资源变为可用，那么当前线程成功获得锁，同时持有count设置为1，返回true.
 * => lockInterruptibly()获取锁是以排他的模式获取，一旦被中断就放弃等待获取。在等待开始时首先检测中断状态，然后至少调用一次tryAcquire，成功获取就返回true。
 *    否则当前线程就开始排队，并且不断的被blocking、unblocking、invoking tryAcquire 直到获取成功或者被中断为止。
 */
/**
* lock 优先考虑获取锁，待获取锁成功后，才响应中断，而lockInterruptibly 优先考虑响应中断。
* 即：lock方法不允许Thread.interrupt中断,即使检测到Thread.isInterrupted,一样会继续尝试获取锁，不会跑出异常；尝试获取失败则继续阻塞，获取锁成功后再把当前线程置为interrupted状态,然后再中断线程。
* lockInterruptibly允许在等待时由其它线程调用等待线程的Thread.interrupt方法来中断等待线程的等待而直接返回，这时不用获取锁，而会抛出一个InterruptedException。
* 即：ThreadA进行lockInterruptibly，在ThreadB中调用ThreadA的interrupt方法，致使ThreadA不用获取锁，而是跑出异常。
* */
~~~